/**
* This controller is responsible for developer login and registration
* It handles the following routes
* 1. /api/user/login
* 2. /api/user/register
* @author  Enokela Acheme Paul
* @email    achemepaulenokela@gmail.com
* @version 1.0
*/
package org.byteworks.javatest;

import java.util.HashMap;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import org.mindrot.jbcrypt.BCrypt;






@RestController
public class UserController {
    @Autowired // This means to get the bean called userRepository
               // Which is auto-generated by Spring, we will use it to handle the data
    private UserRepository userRepository;

    // response Hashmap
    private HashMap<String, Object> res;

    @RequestMapping(value="/api/user/login", method=RequestMethod.POST)
    public HashMap<String, Object> login(
            @RequestParam(value = "email", defaultValue = "") String email,
            @RequestParam(value = "password", defaultValue = "") String rawPassword) {
        res = new HashMap<>();

        Optional<User> user = userRepository.findByEmail(email.toLowerCase());

        if (!user.isPresent())
            return ErrorResponse.respond(Constants.ERROR_INCORRECT_CREDENTIALS);

        //BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

        //compare password to see if it matches
        if (!BCrypt.checkpw(rawPassword, user.get().getPassword()))
            return ErrorResponse.respond(Constants.ERROR_INCORRECT_CREDENTIALS);


        res.put("success", true);
        res.put("user", user);
        return res;

    }

    @RequestMapping(value="/api/user/register", method=RequestMethod.POST)
    public HashMap<String, Object> register(
            @RequestParam(value = "firstName", required = true) String firstName,
            @RequestParam(value = "lastName", required = true) String lastName,
            @RequestParam(value = "email", required = true) String email,
            @RequestParam(value = "password", required = true) String password,
            @RequestParam(value = "repeatPassword", required = true) String repeatPassword) {

        res = new HashMap<>();

        if (!password.equals(repeatPassword)) {
            return ErrorResponse.respond(Constants.ERROR_PASS_MISMATCH);

        }

        if (!EmailValidator.validateEmail(email)) {
            return ErrorResponse.respond(Constants.ERROR_INVALID_EMAIL);

        }

        Optional<User> existingMail = userRepository.findByEmail(email);
        if (existingMail.isPresent()) {
            return ErrorResponse.respond(Constants.ERROR_EXISTING_MAIL);

        }

       // BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
        //encode password
        String encodedPassword = BCrypt.hashpw(password, BCrypt.gensalt());

        User user = new User(firstName, lastName, email.toLowerCase(), encodedPassword);
        userRepository.save(user);

        res.put("success", true);
        res.put("msg", Constants.SUCCESS_SIGNUP);

        return res;
    }

}
